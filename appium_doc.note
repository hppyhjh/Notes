===appium/docs/cn/writing-running-appium/touch-actions.md 
While Selenium WebDriver spec has support for certain kinds of mobile
interaction, its parameters are not always easily mappable to the functionality
that the underlying device automation (like UIAutomation in the case of iOS)
provides. 
To that end, Appium implements the new TouchAction / MultiAction API
defined in the newest version of the spec
this is different from the earlier version of the TouchAction API in
the original JSON Wire Protocol.

These APIs allow you to build up arbitrary gestures with multiple actuators.
see Appium client docs for your language in order to find examples
of using this API.

*MultiTouch* objects are collections of TouchActions.

The best way to interact with the slider on Android is with TouchActions.

uiautomator2.md::
UIObject2, Unlike UiObject, the UIElement is bound to a particular view instance and can become stale if the underlying view object is destroyed. 
UIAutomator 2 utilizes capabilities of Gradle as a build system. Previous, UIAutomator used Maven/Ant.
Test packages produced are now APKs. Previously, UIAutomator produced .jar or .zip files. This makes UIAutomator 2 completely Android instrumentation capable.

The original version of UiAutomator ran as a shell program:
```adb shell uiautomator runtest ...```
UiAutomator 2 is based on Android Instrumentation. Tests are compiled to APKs, and run in an application process:
```adb shell am instrument ...```


===appium/docs/cn/appium-setup/android-hax-emulator.md ...md
runs on an Intel® cpu, you can check out HAXM. leverage your hardware for
virtualization, accelerating the emulator.
To install HAXM open the Android SDK Manager, you will find the package under Extras.
require an x86 emulator image
android-setup.md:: 
1.install Node.js (>v4)
2.install Android SDK (blocked). run 'android' tool to install > API Level 17

(If you want to run Appium from source, you will also need [Apache Ant](http://ant.apache.org/) to build the bootstrap jar that Appium uses for running against Android simulators/devices.)
到这里就配置好了。。。
run `npm install` from your Appium checkout to install all the
dependencies.

Appium uses, comes prepackaged with, a project called [Selendroid](https://selendroid.io) for running Android
versions 2.3 to 4.1.  Appium switches to using Selendroid automatically when it
detects older versions

parallel_tests.md::
to automate multiple Android sessions on a single machine. All it involves is starting multiple Appium servers with different flags.

=== appium/docs/cn/contributing-to-appium/appium-from-source.md 
gulp是前端开发过程中对代码进行构建的工具



=== appium/docs/en/advanced-concepts/settings.md 
Settings are a new concept introduced by appium. currently not a part of the Mobile JSON Wire Protocol, or the Webdriver spec.
a way to specify the behavior of the appium server.
Control the way the appium server behaves during test automation.  not apply to controlling the app or device under test.

===appium/docs/cn/writing-running-appium/windows-app-testing.md 
Windows specific UI testing on Appium is powered by WinAppDriver, which is downloaded as part of Appium install.
Windows Application Driver supports testing Universal Windows Platform (UWP) and Classic Windows (Win32) apps on Windows 10 PC  --- ON PC

===docs/en/about-appium/intro.md
#NOT do anything to be-tested APP
using vendor-provided automation frameworks under the hood. That way, we don't need to compile in any Appium-specific or third-party code or frameworks to your app. This means you're testing the same app you're shipping. The vendor-provided frameworks we use are:

#NOT locked into a specific lang & framework
wrapping the vendor-provided frameworks in one API, the WebDriver API. WebDriver (aka "Selenium WebDriver") specifies a client-server protocol (known as the JSON Wire Protocol). 
Given this client-server architecture, a client written in any language can be used to send the appropriate HTTP requests to the server. There are already clients written in every popular programming language. This also means that you're free to use whatever test runner and test framework you want; the client libraries are simply HTTP clients and can be mixed into your code any way you please. In other words, Appium & WebDriver clients are not technically "test frameworks" -- they are "automation libraries". 

Appium is at its heart a webserver that exposes a REST API.
we can write our test code in any language that has a http client API, but it is easier to use one of the Appium client libraries. We can put the server on a different machine than our tests are running on. We can write test code and rely on a cloud service like Sauce Labs to receive and interpret the commands.

Session & Desired Capabilities

There are client libraries (in Java, Ruby, Python, PHP, JavaScript, and C#) which support Appium's extensions to the WebDriver protocol. When using Appium, you want to use these client libraries instead of your regular WebDriver client. 

#NOT reinvent the wheel
WebDriver has become the de facto standard for automating web browsers, a W3C Working Draft. we have extended the protocol with extra API methods useful for mobile automation.  --只是浏览器，原生应用呢

===Appium Python Client
An extension library for adding Selenium 3.0 draft and Mobile JSON Wire Protocol Specification draft functionality to the Python language bindings, for use with the mobile testing framework Appium.

The majority of the usage remains as it has been for Selenium 2 (WebDriver), and as the official Selenium Python bindings begins to implement the new specification that implementation will be used underneath, so test code can be written that is utilizable with both bindings.



